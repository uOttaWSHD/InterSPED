<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" type="image/png" href="/assets/img/favicon.png">
  <link rel="stylesheet" href="/assets/css/uikit.min.css" />
  <script src="/assets/js/uikit.min.js" type="text/javascript"></script>
  <script src="/assets/js/uikit-icons.min.js" type="text/javascript"></script>

  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  
  

  
<!-- below block is overlapping with SEO plugin generated title and description   -->
<!-- 
  <title>103 - Binary Tree Zigzag Level Order Traversal</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Welcome to Subscribe On Youtube 103. Binary Tree Zigzag Level Order Traversal Description Given the root of a binary tree, return the zigzag level order traversal of its nodes&amp;#39; values. (i.e., from left to right, then right to left for the next level and alternate between). &amp;nbsp; Example 1: Input:...">
   -->

  

  
  <meta name="keywords" content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada">
  

  <link rel="alternate" type="application/rss+xml" title="Leetcode" href="https://leetcode.ca/feed.xml">

  

  

  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
  </script>
  <!-- End Google Analytics -->


  
  <script data-ad-client="ca-pub-6766885420008650" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>



  
    
      
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">


    
      
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800">


    
  

  
    
      <link rel="stylesheet" href="/assets/css/bootstrap-social.css">
    
      <link rel="stylesheet" href="/assets/css/beautifuljekyll.css">
    
  

  

  

  

  

  
  <meta property="og:site_name" content="Leetcode">
  <meta property="og:title" content="103 - Binary Tree Zigzag Level Order Traversal">
  <meta property="og:description" content="Welcome to Subscribe On Youtube 103. Binary Tree Zigzag Level Order Traversal Description Given the root of a binary tree, return the zigzag level order traversal of its nodes&amp;#39; values. (i.e., from left to right, then right to left for the next level and alternate between). &amp;nbsp; Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[3],[20,9],[15,7]] Example 2: Input: root = [1] Output: [[1]] Example 3: Input: root = [] Output: [] &amp;nbsp; Constraints: The number of nodes in the tree is in the range [0, 2000]. -100 &amp;lt;= Node.val &amp;lt;= 100 Solutions Solution 1: BFS To implement zigzag level order traversal, we need to add a flag left on the basis of level order traversal. This flag is used to mark the order of the node values in the current level. If left is true, the node values of the current level are stored in the result array ans from left to right. If left is false, the node values of the current level are stored in the result array ans from right to left. The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree. Java C++ Python Go TypeScript Javascript RenderScript /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); if (root == null) { return ans; } Deque&amp;lt;TreeNode&amp;gt; q = new ArrayDeque&amp;lt;&amp;gt;(); q.offer(root); boolean left = true; while (!q.isEmpty()) { List&amp;lt;Integer&amp;gt; t = new ArrayList&amp;lt;&amp;gt;(); for (int n = q.size(); n &amp;gt; 0; --n) { TreeNode node = q.poll(); t.add(node.val); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } if (!left) { Collections.reverse(t); } ans.add(t); left = !left; } return ans; } } ////// public class Binary_Tree_Zigzag_Level_Order_Traversal { /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ // count as level marker class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); if (root == null) { return result; } boolean isLeftToRight = true; Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(root); int currentLevelCount = 1; int nextLevelCount = 0; List&amp;lt;Integer&amp;gt; one = new ArrayList&amp;lt;&amp;gt;(); while (!q.isEmpty()) { TreeNode current = q.poll(); currentLevelCount--; if (isLeftToRight) { one.add(current.val); } else { one.add(0, current.val); } if (current.left != null) { q.offer(current.left); nextLevelCount++; } if (current.right != null) { q.offer(current.right); nextLevelCount++; } if (currentLevelCount == 0) { currentLevelCount = nextLevelCount; nextLevelCount = 0; result.add(one); one = new ArrayList&amp;lt;&amp;gt;(); isLeftToRight = !isLeftToRight; } } return result; } } public class Solution_nullAsMarker { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) {...">

  
  <meta property="og:image" content="https://leetcode.ca/assets/img/avatar-icon.jpg">
  

  <!-- remove canonical below to use SEO plugin -->
  
  <meta property="og:type" content="article">
  <meta property="og:article:author" content="Leetcode">
  <meta property="og:article:published_time" content="2016-03-12T00:00:00-08:00">
  <meta property="og:url" content="https://leetcode.ca/2016-03-12-103-Binary-Tree-Zigzag-Level-Order-Traversal/">
  <!-- <link rel="canonical" href="https://leetcode.ca/2016-03-12-103-Binary-Tree-Zigzag-Level-Order-Traversal/"> -->
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:site" content="@">
  <meta name="twitter:creator" content="@">

  <meta property="twitter:title" content="103 - Binary Tree Zigzag Level Order Traversal">
  <meta property="twitter:description" content="Welcome to Subscribe On Youtube 103. Binary Tree Zigzag Level Order Traversal Description Given the root of a binary tree, return the zigzag level order traversal of its nodes&amp;#39; values. (i.e., from left to right, then right to left for the next level and alternate between). &amp;nbsp; Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[3],[20,9],[15,7]] Example 2: Input: root = [1] Output: [[1]] Example 3: Input: root = [] Output: [] &amp;nbsp; Constraints: The number of nodes in the tree is in the range [0, 2000]. -100 &amp;lt;= Node.val &amp;lt;= 100 Solutions Solution 1: BFS To implement zigzag level order traversal, we need to add a flag left on the basis of level order traversal. This flag is used to mark the order of the node values in the current level. If left is true, the node values of the current level are stored in the result array ans from left to right. If left is false, the node values of the current level are stored in the result array ans from right to left. The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree. Java C++ Python Go TypeScript Javascript RenderScript /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); if (root == null) { return ans; } Deque&amp;lt;TreeNode&amp;gt; q = new ArrayDeque&amp;lt;&amp;gt;(); q.offer(root); boolean left = true; while (!q.isEmpty()) { List&amp;lt;Integer&amp;gt; t = new ArrayList&amp;lt;&amp;gt;(); for (int n = q.size(); n &amp;gt; 0; --n) { TreeNode node = q.poll(); t.add(node.val); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } if (!left) { Collections.reverse(t); } ans.add(t); left = !left; } return ans; } } ////// public class Binary_Tree_Zigzag_Level_Order_Traversal { /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ // count as level marker class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); if (root == null) { return result; } boolean isLeftToRight = true; Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(root); int currentLevelCount = 1; int nextLevelCount = 0; List&amp;lt;Integer&amp;gt; one = new ArrayList&amp;lt;&amp;gt;(); while (!q.isEmpty()) { TreeNode current = q.poll(); currentLevelCount--; if (isLeftToRight) { one.add(current.val); } else { one.add(0, current.val); } if (current.left != null) { q.offer(current.left); nextLevelCount++; } if (current.right != null) { q.offer(current.right); nextLevelCount++; } if (currentLevelCount == 0) { currentLevelCount = nextLevelCount; nextLevelCount = 0; result.add(one); one = new ArrayList&amp;lt;&amp;gt;(); isLeftToRight = !isLeftToRight; } } return result; } } public class Solution_nullAsMarker { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) {...">

  
  <meta name="twitter:image" content="https://leetcode.ca/assets/img/avatar-icon.jpg">
  

  


  <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>103 - Binary Tree Zigzag Level Order Traversal | Leetcode</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="103 - Binary Tree Zigzag Level Order Traversal" />
<meta name="author" content="Leetcode" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Welcome to Subscribe On Youtube" />
<meta property="og:description" content="Welcome to Subscribe On Youtube" />
<link rel="canonical" href="https://leetcode.ca/2016-03-12-103-Binary-Tree-Zigzag-Level-Order-Traversal/" />
<meta property="og:url" content="https://leetcode.ca/2016-03-12-103-Binary-Tree-Zigzag-Level-Order-Traversal/" />
<meta property="og:site_name" content="Leetcode" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-03-12T00:00:00-08:00" />
<script type="application/ld+json">
{"description":"Welcome to Subscribe On Youtube","headline":"103 - Binary Tree Zigzag Level Order Traversal","dateModified":"2016-03-12T00:00:00-08:00","datePublished":"2016-03-12T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-03-12-103-Binary-Tree-Zigzag-Level-Order-Traversal/"},"url":"https://leetcode.ca/2016-03-12-103-Binary-Tree-Zigzag-Level-Order-Traversal/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  

  

</head>


<body>

  


  <nav class="navbar navbar-expand-xl navbar-light fixed-top navbar-custom top-nav-regular"><a class="navbar-brand" href="https://leetcode.ca/">Leetcode</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="main-navbar">
    <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link" href="/blog">Posts</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/tags">Tag Index</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/search">Search</a>
          </li></ul>
  </div>

  

  
    <div class="avatar-container">
      <div class="avatar-img-border">
        <a href="https://leetcode.ca/">
          <img alt="Navigation bar avatar" class="avatar-img" src="/assets/img/avatar-icon.jpg" />
        </a>
      </div>
    </div>
  

</nav>


  <!-- TODO this file has become a mess, refactor it -->







<header class="header-section ">

<div class="intro-header no-img">
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>103 - Binary Tree Zigzag Level Order Traversal</h1>
          

          
            <span class="post-meta">Posted on March 12, 2016</span>
            
            
              





  
  <span class="post-meta"><span class="d-none d-md-inline middot">&middot;</span> 8 minute read</span>


            
          
        </div>
      </div>
    </div>
  </div>
</div>
</header>





<div class=" container-md ">
  <div class="row">
    <div class=" col-xl-8 offset-xl-2 col-lg-10 offset-lg-1 ">

      

      

      <article role="main" class="blog-post">
        <h5 id="welcome-to-subscribe-on-youtube">Welcome to Subscribe On Youtube</h5>
<script src="https://apis.google.com/js/platform.js"></script>

<div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-layout="full" data-count="hidden"></div>

<h1 id="103-binary-tree-zigzag-level-order-traversal"><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal">103. Binary Tree Zigzag Level Order Traversal</a></h1>

<h2 id="description">Description</h2>

<p>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes&#39; values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<p><img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0103.Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/images/tree1.jpg" style="width: 277px; height: 302px;" /></p>
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[3],[20,9],[15,7]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [[1]]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<h2 id="solutions">Solutions</h2>

<p><strong>Solution 1: BFS</strong></p>

<p>To implement zigzag level order traversal, we need to add a flag <code class="language-plaintext highlighter-rouge">left</code> on the basis of level order traversal. This flag is used to mark the order of the node values in the current level. If <code class="language-plaintext highlighter-rouge">left</code> is <code class="language-plaintext highlighter-rouge">true</code>, the node values of the current level are stored in the result array <code class="language-plaintext highlighter-rouge">ans</code> from left to right. If <code class="language-plaintext highlighter-rouge">left</code> is <code class="language-plaintext highlighter-rouge">false</code>, the node values of the current level are stored in the result array <code class="language-plaintext highlighter-rouge">ans</code> from right to left.</p>

<p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree.</p>

<ul class="uk-tab" data-uk-switcher="{connect:'#e6a39ce8-5832-4624-815c-395fbdfe1c1f'}">

	<li class="uk-active"><a href="#">Java</a></li>

	<li><a href="#">C++</a></li>

	<li><a href="#">Python</a></li>

	<li><a href="#">Go</a></li>

	<li><a href="#">TypeScript</a></li>

	<li><a href="#">Javascript</a></li>

	<li><a href="#">RenderScript</a></li>

</ul>

<ul id="e6a39ce8-5832-4624-815c-395fbdfe1c1f" class="uk-switcher uk-margin">

	<li>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">zigzagLevelOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">t</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">left</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Collections</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
            <span class="n">left</span> <span class="o">=</span> <span class="o">!</span><span class="n">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//////</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Binary_Tree_Zigzag_Level_Order_Traversal</span> <span class="o">{</span>

    <span class="cm">/**
     * Definition for a binary tree node.
     * public class TreeNode {
     * int val;
     * TreeNode left;
     * TreeNode right;
     * TreeNode(int x) { val = x; }
     * }
     */</span>

    <span class="c1">// count as level marker</span>
    <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">zigzagLevelOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>

            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="kt">boolean</span> <span class="n">isLeftToRight</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

            <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

            <span class="kt">int</span> <span class="n">currentLevelCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">nextLevelCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">one</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

            <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">TreeNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">currentLevelCount</span><span class="o">--;</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">isLeftToRight</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">one</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">one</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">current</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                    <span class="n">nextLevelCount</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                    <span class="n">nextLevelCount</span><span class="o">++;</span>
                <span class="o">}</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">currentLevelCount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">currentLevelCount</span> <span class="o">=</span> <span class="n">nextLevelCount</span><span class="o">;</span>
                    <span class="n">nextLevelCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

                    <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">one</span><span class="o">);</span>
                    <span class="n">one</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

                    <span class="n">isLeftToRight</span> <span class="o">=</span> <span class="o">!</span><span class="n">isLeftToRight</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution_nullAsMarker</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">zigzagLevelOrder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>

            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;();</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span><span class="c1">// @note: use null as marker for end of level</span>

            <span class="kt">boolean</span> <span class="n">direction</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// true: left=&gt;right, false: right=&gt;left</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">oneLevel</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>

                <span class="nc">TreeNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">oneLevel</span><span class="o">);</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">copy</span><span class="o">);</span>

                    <span class="c1">// clean after one level recorded</span>
                    <span class="n">oneLevel</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span><span class="c1">// @memorize: this api</span>
                    <span class="n">direction</span> <span class="o">=</span> <span class="o">!</span><span class="n">direction</span><span class="o">;</span>

                    <span class="c1">// @note:@memorize: if stack is now empty then DO NOT add null, or else infinite looping</span>
                    <span class="c1">// sk.offer(null); // add marker</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// add marker</span>
                    <span class="o">}</span>

                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">direction</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">oneLevel</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">oneLevel</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">current</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="c1">// @note:@memorize: since using null as marker, then must avoid adding null when children are null</span>
                <span class="c1">// sk.offer(current.left);</span>
                <span class="c1">// sk.offer(current.right);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="o">}</span>

            <span class="o">}</span>

            <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>
</li>

	<li>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">zigzagLevelOrder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">{</span> <span class="p">{</span><span class="n">root</span><span class="p">}</span> <span class="p">};</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">n</span><span class="p">;</span> <span class="o">--</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
                <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                <span class="n">t</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="p">)</span> <span class="n">reverse</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
            <span class="n">left</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
</li>

	<li>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span>
<span class="s">'''
can also use list.insert()

&gt;&gt;&gt; my_list = [2, 3, 4]
&gt;&gt;&gt; my_list.insert(0, 1)  # Insert 1 at the head of the list
&gt;&gt;&gt; print(my_list)  # Output: [1, 2, 3, 4]


&gt;&gt;&gt; a = deque([])
&gt;&gt;&gt; a
deque([])
&gt;&gt;&gt; a.append(1)
&gt;&gt;&gt; a.append(2)
&gt;&gt;&gt; a.append(3)
&gt;&gt;&gt; a
deque([1, 2, 3])
&gt;&gt;&gt;
&gt;&gt;&gt; a.append(0, 555)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: deque.append() takes exactly one argument (2 given)
&gt;&gt;&gt; a.insert(0, 555)
&gt;&gt;&gt; a
deque([555, 1, 2, 3])
'''</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">zigzagLevelOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ans</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">t</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span> <span class="k">if</span> <span class="n">left</span> <span class="k">else</span> <span class="n">t</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">left</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>

<span class="c1">############
</span>
<span class="c1"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">zigzagLevelOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="s">"""
    :type root: TreeNode
    :rtype: List[List[int]]
    """</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">odd</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
      <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)):</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">top</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
          <span class="k">continue</span>
        <span class="n">level</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">level</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">odd</span><span class="p">:</span>
          <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">level</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
      <span class="n">odd</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">odd</span>
    <span class="k">return</span> <span class="n">ans</span>

<span class="c1">############
</span>
<span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">zigzagLevelOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ans</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">t</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span> <span class="k">if</span> <span class="n">left</span> <span class="k">else</span> <span class="n">t</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">left</span> <span class="o">^=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ans</span>

</code></pre></div></div>
</li>

	<li>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">func</span> <span class="n">zigzagLevelOrder</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">(</span><span class="n">ans</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="n">q</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">{</span><span class="n">root</span><span class="p">}</span>
	<span class="n">left</span> <span class="o">:=</span> <span class="no">true</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
		<span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">);</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span> <span class="p">{</span>
			<span class="n">node</span> <span class="o">:=</span> <span class="n">q</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
			<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
			<span class="n">t</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">Left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="n">q</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">Right</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="n">q</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="o">!</span><span class="n">left</span> <span class="p">{</span>
			<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="m">1</span> <span class="p">{</span>
				<span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ans</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
		<span class="n">left</span> <span class="o">=</span> <span class="o">!</span><span class="n">left</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div>
</li>

	<li>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">zigzagLevelOrder</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="kr">number</span><span class="p">[][]</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">isDesc</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">root</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">slice</span><span class="p">().</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="p">{</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
            <span class="nx">left</span> <span class="o">&amp;&amp;</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">left</span><span class="p">);</span>
            <span class="nx">right</span> <span class="o">&amp;&amp;</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">right</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">val</span><span class="p">;</span>
        <span class="p">});</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">isDesc</span> <span class="p">?</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span> <span class="p">:</span> <span class="nx">arr</span><span class="p">);</span>
        <span class="nx">isDesc</span> <span class="o">=</span> <span class="o">!</span><span class="nx">isDesc</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
</li>

	<li>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="cm">/**
 * @param {TreeNode} root
 * @return {number[][]}
 */</span>
<span class="kd">var</span> <span class="nx">zigzagLevelOrder</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">ans</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">ans</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">q</span> <span class="o">=</span> <span class="p">[</span><span class="nx">root</span><span class="p">];</span>
    <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">n</span><span class="p">;</span> <span class="o">--</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
            <span class="nx">t</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">t</span><span class="p">.</span><span class="nx">reverse</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="nx">ans</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">t</span><span class="p">);</span>
        <span class="nx">left</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ans</span><span class="p">;</span>
<span class="p">};</span>

</code></pre></div></div>
</li>

	<li>
<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Definition for a binary tree node.</span>
<span class="c1">// #[derive(Debug, PartialEq, Eq)]</span>
<span class="c1">// pub struct TreeNode {</span>
<span class="c1">//   pub val: i32,</span>
<span class="c1">//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span>
<span class="c1">//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span>
<span class="c1">// }</span>
<span class="c1">//</span>
<span class="c1">// impl TreeNode {</span>
<span class="c1">//   #[inline]</span>
<span class="c1">//   pub fn new(val: i32) -&gt; Self {</span>
<span class="c1">//     TreeNode {</span>
<span class="c1">//       val,</span>
<span class="c1">//       left: None,</span>
<span class="c1">//       right: None</span>
<span class="c1">//     }</span>
<span class="c1">//   }</span>
<span class="c1">// }</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">zigzag_level_order</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="k">if</span> <span class="n">root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">is_desc</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">q</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span> <span class="o">!</span><span class="n">q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">arr</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">q</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="nf">.borrow_mut</span><span class="p">();</span>
                    <span class="n">arr</span><span class="nf">.push</span><span class="p">(</span><span class="n">node</span><span class="py">.val</span><span class="p">);</span>
                    <span class="k">if</span> <span class="n">node</span><span class="py">.left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">node</span><span class="py">.left</span><span class="nf">.take</span><span class="p">());</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="n">node</span><span class="py">.right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">node</span><span class="py">.right</span><span class="nf">.take</span><span class="p">());</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">is_desc</span> <span class="p">{</span>
                <span class="n">arr</span><span class="nf">.reverse</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">is_desc</span> <span class="o">=</span> <span class="o">!</span><span class="n">is_desc</span><span class="p">;</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">res</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>
</li>

</ul>

<h1 id="all-problems"><a href="https://leetcode.ca/all/problems.html">All Problems</a></h1>

<h1 id="all-solutions"><a href="https://leetcode.ca/blog">All Solutions</a></h1>

      </article>

      

      

      
        <!-- Check if any share-links are active -->




<section id = "social-share-section">
  <span class="sr-only">Share: </span>

  
    <a href="https://twitter.com/intent/tweet?text=103+-+Binary+Tree+Zigzag+Level+Order+Traversal&url=https%3A%2F%2Fleetcode.ca%2F2016-03-12-103-Binary-Tree-Zigzag-Level-Order-Traversal%2F"
      class="btn btn-social-icon btn-twitter" title="Share on Twitter">
      <span class="fab fa-fw fa-twitter" aria-hidden="true"></span>
      <span class="sr-only">Twitter</span>
    </a>
  

  
    <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fleetcode.ca%2F2016-03-12-103-Binary-Tree-Zigzag-Level-Order-Traversal%2F"
      class="btn btn-social-icon btn-facebook" title="Share on Facebook">
      <span class="fab fa-fw fa-facebook" aria-hidden="true"></span>
      <span class="sr-only">Facebook</span>
    </a>
  

  
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fleetcode.ca%2F2016-03-12-103-Binary-Tree-Zigzag-Level-Order-Traversal%2F"
      class="btn btn-social-icon btn-linkedin" title="Share on LinkedIn">
      <span class="fab fa-fw fa-linkedin" aria-hidden="true"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  

  

</section>



      

      <ul class="pagination blog-pager">
        
        <li class="page-item previous">
          <a class="page-link" href="/2016-03-11-102-Binary-Tree-Level-Order-Traversal/" data-toggle="tooltip" data-placement="top" title="102 - Binary Tree Level Order Traversal">&larr; Previous Post</a>
        </li>
        
        
        <li class="page-item next">
          <a class="page-link" href="/2016-03-13-104-Maximum-Depth-of-Binary-Tree/" data-toggle="tooltip" data-placement="top" title="104 - Maximum Depth of Binary Tree">Next Post &rarr;</a>
        </li>
        
      </ul>
      
  <div class="disqus-comments">
  <div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
	  var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</div>
  
  

  




    </div>
  </div>
</div>


  <footer>
  <div class="container-md beautiful-jekyll-footer">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
      <ul class="list-inline text-center footer-links"><li class="list-inline-item">
    <a href="/feed.xml" title="RSS">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">RSS</span>
    </a>
  </li><li class="list-inline-item">
    <a href="mailto:admin@leetcode.ca" title="Email me">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Email me</span>
   </a>
  </li></ul>

      
      <p class="copyright text-muted">
      
        Leetcode
        &nbsp;&bull;&nbsp;
      
      2026

      
        &nbsp;&bull;&nbsp;
        <span class="author-site">
          <a href="https://leetcode.ca/">leetcode.ca</a>
        </span>
      

      
      </p>
      
      <p class="theme-by text-muted">
        Copyright  2025 leetcode.ca
      </p>
      </div>
    </div>
  </div>
</footer>


  
  
    
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" crossorigin="anonymous"></script>


  
    
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>


  
    
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>


  



  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="/assets/js/beautifuljekyll.js"></script>
    
  





  
    
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
    
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js"></script>


  



  
    <script src="/assets/js/anchor-js-config.js"></script>
  



</body>
</html>
